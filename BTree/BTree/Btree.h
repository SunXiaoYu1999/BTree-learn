#pragma once
#include <iostream>
#include <string>

using std::string;

typedef string DataType;

typedef struct Node
{
	DataType        data;       // 数据
	struct Node*    lChild;     // 左孩子
	struct Node*    rChild;     // 右孩子

	int             height;     // 树节点的高度
	double          weight;     // 权重
	int             flagL;      // 左标记   0是上一个节点，1是左孩子
	int             flagR;      // 右标记   0是下一个节点，1是右孩子
}BTree;

//--------------------------------- 创建树 -----------------------------------------------------------------------
// 函数说明		：应用一个数组elems[n]来创建一棵二叉树。elems[1]放入树根的节点数据，elems[2*i]为elems[i]的左
//				  孩子节点数据，elems[2*i+1]为elems[i]d的右孩子节点数据。elems[k] = "#"代表为空节点。
// @param elems :数据元素
// @param num	:数据元素个数
// 注意！！！	：数据元素下表从1开始，而非数组下表0；
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CreateBTreeByArray(BTree *&bTree, DataType elems[], int num);

//--------------------------------- 先根遍历递归方法 ------------------------------------------------------------
// 函数说明		：先序遍历一个二叉树，树根节点bTree, Print为一个函数指针，由外部传入，用来打印节点值；用法如下
//				  <1> 先定义一个打印函数 Print,如下：
//					bool Print(DataType data)
//					{
//						cout << " " << data << " ";
//						return true;
//					}
//				  <2> 按如下方式调用：
//					PreOrder_DiGui(bTree, Print);
// @param bTree ：树根节点
// @param Visit	：访问函数指针，负责访问节点值
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void PreOrder_DiGui(BTree *bTree, bool(*Visit)(BTree* Node));

//--------------------------------- 中序遍历递归方法 ------------------------------------------------------------
// 函数说明		：中序遍历一个二叉树，树根节点bTree, Print为一个函数指针，由外部传入，用来打印节点值	  
// @param bTree ：树根节点
// @param Visit	：访问函数指针，负责访问节点值
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void InOrder_DiGui(BTree *bTree, bool(*Visit)(BTree* Node));


//--------------------------------- 后根遍历递归方法 ------------------------------------------------------------
// 函数说明		：后序遍历一个二叉树，树根节点bTree, Print为一个函数指针，由外部传入，用来打印节点值	  
// @param bTree ：树根节点
// @param Visit	：访问函数指针，负责访问节点值
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void PostOrder_DiGui(BTree *bTree, bool(*Visit)(BTree* Node));

//--------------------------------- 先序遍历非递归法 ------------------------------------------------------------
// 函数说明		：先序遍历一个二叉树，树根节点bTree, Print为一个函数指针，由外部传入，用来打印节点值	  
// @param bTree ：树根节点
// @param Visit	：访问函数指针，负责访问节点值
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void PreOrder_NoDiGui(BTree *bTree, bool(*Visit)(BTree* Node));

//--------------------------------- 中序遍历非递归法 ------------------------------------------------------------
// 函数说明		：中序遍历一个二叉树，树根节点bTree, Print为一个函数指针，由外部传入，用来打印节点值	  
// @param bTree ：树根节点
// @param Visit	：访问函数指针，负责访问节点值
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void InOrder_NoDiGui(BTree *bTree, bool(*Visit)(BTree* Node));

//--------------------------------- 后序遍历非递归法 ------------------------------------------------------------
// 函数说明		：后序遍历一个二叉树，树根节点bTree, Print为一个函数指针，由外部传入，用来打印节点值	  
// @param bTree ：树根节点
// @param Visit	：访问函数指针，负责访问节点值
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void PostOrder_NoDiGui(BTree *bTree, bool(*Visit)(BTree* Node));

//--------------------------------- 打印节点X的所有祖先节点 -----------------------------------------------------
// 函数说明		：打印节点值为X的所有祖先节点	  
// @param bTree ：树根节点
// @param X		：数值X
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void PrintParentOfXNode(BTree *bTree, DataType X);

//--------------------------------- 创建二叉树 ------------------------------------------------------------------
// 函数说明		：根据先序跟中序序列创建一个二叉树 
// @param Pre[] ：先序序列
// @param In[]	：中序序列
// @param num	：节点个数
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BTree* CreateBTree_PreOrderAndInOrder(string Pre[], string In[], int num);
/*下面函数是求解需要函数*/
BTree* CreateBTree_PreOrderInOrder(string Pre[], int preL, int preR, string In[], int InL, int InR);

//--------------------------------- 销毁一个二叉树 --------------------------------------------------------------
// 函数说明		：销毁一个二叉树
// @param bTree	：树根节点
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void DestoryBTree(BTree *& bTree);


/****************************************************************************************************************/
/*********************************************** 下面是王道的题目 ***********************************************/
/****************************************************************************************************************/

// 10、求中序遍历第K个节点的数据
DataType ValueOfKInOrder(BTree *bTree, int k);
void Solution_10(BTree *bTree, int k, int &curCount, int &find, DataType &findData);

// 11、删除元素值为x的节点
void DeleteXNode(BTree *& bTree, DataType X);

// 15、对满二叉树由先序序列求出后序序列
void PreOrderGuessPostOrder(DataType A[], int num);
void Solution_15(DataType A[], int AL, int AR);

// 16、将所有叶子节点链接成单链表
BTree* LinkLeafToList(BTree *bTree);
void Solution_16(BTree *bTree, BTree *&preNode);

// 17、线索化二叉树	
/********************************************** 带头节点的线索化二叉树 ******************************************/
// 说明 : '_' 开头的函数为辅助函数，不应该直接调用。调用时主要调用不带 '_' 的函数
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//---------------------------------- 线索化一个二叉树 -----------------------------------------------------------
// @param	root：待被线索化的二叉树
// 函数说明		：该函数线索化一颗二叉树，返回线索化后的头节点
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BTree* TreadBTree(BTree *root);
void _Inorder_TreadBTree(BTree *&curNode, BTree *&preNode);
// 寻找当前节点在线索树中找后继的第一个节点
BTree* TreadFindFirstR(BTree *root);
// 寻找当前节点在线索树中找前驱的第一个节点
BTree* TreadFindFirstL(BTree *root);
// 寻找当前节点的后继节点
BTree* TreadFindNext(BTree *root);
// 寻找当前节点的前驱节点
BTree* TreadFindPrior(BTree *root);

// 18、求二叉树的带权叶子路径和WPL
double CalSumOfLeaf(BTree *root);
void _Solution_18(BTree *root, double &sum, double preWeight, int height);
void SetWeight(BTree *root, double w[], int wLen);
